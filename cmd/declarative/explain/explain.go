// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2025 The Falco Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package explain

import (
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/spf13/cobra"
	"github.com/thediveo/enumflag"

	"github.com/falcosecurity/event-generator/pkg/test/loader/schema"
)

const (
	longDescriptionHeading  = "Document test(s) YAML description properties"
	longDescriptionTemplate = `%s.
Documentation is generated by following the property hierarchies in the YAML description.

The <propertyPathExpr> can be used to specify to output the documentation for the desired properties. The expression is
composed by one or multiple dot-separated property path segments. Each property path segment follows the following
syntax: <propertyName>[{<enumProperty1>=<value1>}[{<enumProperty2>=<value2>}...]].
The optional {<enumPropertyX>=<valueX>} parts are called "enum requirements" and can be used to set the value of an
enumerated property (under the property <propertyName>) to a specific value: this enables the generation of the
documentation for properties enabled only by the presence of that value.
Enum requirements are evaluated in their appearing order, so order matters.
The following examples demonstrate how to specify property path expressions:

event-generator declarative explain tests.context.processes

event-generator declarative explain tests.steps{type=syscall}{syscall=openat2}.args.how

Enum requirements can be provided also by using the --with flag (see --with flag documentation for the syntax). It is
not possible to specify enum requirements both with <propertyPathExpr> and the --with flag.`
)

var (
	longDescription = fmt.Sprintf(longDescriptionTemplate, longDescriptionHeading)
)

// documentationFormat defines the types of format used for outputting the documentation.
type documentationFormat int

const (
	// documentationFormatText specifies to format the documentation using a formatted text encoding.
	documentationFormatText documentationFormat = iota
	// documentationFormatYAML specifies to format the documentation using a YAML encoding.
	documentationFormatYAML
)

var documentationFormats = map[documentationFormat][]string{
	documentationFormatText: {"text"},
	documentationFormatYAML: {"yaml"},
}

// CommandWrapper wraps the command and stores the associated flag values.
type CommandWrapper struct {
	Command *cobra.Command

	// Flags
	//
	// With contains a list of key/value pairs in the form <key>=<value>. Each key is a dot-separated list of property
	// path segments leading to a property accepting enumerated values. This flag is empty if <propertyPathExpr>
	// contains enum requirements.
	with []string
	// docFormat defines the documentation output format.
	docFormat documentationFormat
}

// New creates a new explain command.
func New() *CommandWrapper {
	cw := &CommandWrapper{}
	c := &cobra.Command{
		Use:               "explain [<propertyPathExpr>]",
		Short:             longDescriptionHeading,
		Long:              longDescription,
		DisableAutoGenTag: true,
		RunE:              cw.runE,
	}
	cw.Command = c
	cw.initCommandFlags()
	return cw
}

// initCommandFlags initializes the command's flags.
func (cw *CommandWrapper) initCommandFlags() {
	flags := cw.Command.Flags()

	flags.StringSliceVar(&cw.with, "with", nil,
		"A list of comma-separated enum requirements. An enum requirement is expressed as a <key>=<value> expression. "+
			"Each key is a dot-separated list of property path segments leading to a property accepting enumerated "+
			"values. This flag cannot be used if <propertyPathExpr> contains enum requirements. "+
			"Example: '--with tests.steps.type=syscall,tests.steps.syscall=write'")
	flags.VarP(
		enumflag.New(&cw.docFormat, "format", documentationFormats, enumflag.EnumCaseInsensitive), "format", "f",
		"The output format for the documentation; can be 'text' or 'yaml'")
}

var errForbiddenWithClauses = fmt.Errorf("enum requirements cannot be specified both using <propertyPathExpr> and " +
	"--with clauses")

func (cw *CommandWrapper) runE(_ *cobra.Command, args []string) error {
	var err error
	var propPath []string
	var enumRequirements []*schema.EnumRequirement

	switch argsNum := len(args); argsNum {
	case 0: // keep propPath and enumRequirements set to their default values.
	case 1:
		if propPath, enumRequirements, err = parsePropertyPathExpression(args[0]); err != nil {
			return fmt.Errorf("error parsing property path expression: %w", err)
		}
	default:
		return fmt.Errorf("expected [<propertyPathExpr>], got %d arguments", argsNum)
	}

	if len(enumRequirements) == 0 {
		if enumRequirements, err = parseWithClauses(cw.with); err != nil {
			return fmt.Errorf("error parsing --with clauses: %w", err)
		}
	} else if len(cw.with) > 0 {
		// --with clauses are forbidden if the enum requirements are provided via property path expression.
		return errForbiddenWithClauses
	}

	// Retrieve the tree describing the entire path towards the requested property path.
	rootProperty, err := schema.Describe(propPath, enumRequirements)
	if err != nil {
		return fmt.Errorf("error describing section: %w", err)
	}

	// Print the documentation to stdout.
	if err := printDoc(rootProperty, cw.docFormat); err != nil {
		return fmt.Errorf("error outputting documentation: %w", err)
	}

	return nil
}

// printDoc prints the documentation for the node tree starting at the provided node, by using the provided format
// specifier, to stdout.
func printDoc(node *schema.Node, docFormat documentationFormat) error {
	var encoder documentationEncoder
	switch docFormat {
	case documentationFormatText:
		encoder = newTextEncoder(os.Stdout)
	case documentationFormatYAML:
		encoder = newYAMLEncoder(os.Stdout)
	default:
		panic(fmt.Sprintf("unsupported documentation output format %v", docFormat))
	}

	return encoder.encode(node)
}

var (
	// propPathExprRegex matches against <propertyName>[{<enumProperty1>=<value1>}[{<enumProperty2>=<value2>}...]],
	// capturing (1) <propertyName> and (2) the remaining part as wholes.
	propPathExprRegex = regexp.MustCompile(`^(\w+)((?:{\w+=\w+})*)$`)
	// enumRequirementsRegex matches against [{<enumProperty1>=<value1>}[{<enumProperty2>=<value2>}...]], capturing each
	// couple <enumPropertyX>/<valueX> separately.
	enumRequirementsRegex = regexp.MustCompile(`{(\w+)=(\w+)}+`)
)

var errInvalidPropertyPathSegmentExpr = fmt.Errorf("must match %v", propPathExprRegex.String())

// parsePropertyPathExpression parses the provided property path expression and returns the encoded property path and
// enum requirements.
func parsePropertyPathExpression(propPathExpr string) (propPath []string, enumRequirements []*schema.EnumRequirement,
	err error) {
	segments := strings.Split(propPathExpr, ".")
	for _, segment := range segments {
		matches := propPathExprRegex.FindStringSubmatch(segment)
		if len(matches) == 0 {
			return nil, nil, fmt.Errorf("invalid path segment %q: %w", segment, errInvalidPropertyPathSegmentExpr)
		}

		propName, enumRequirementsExpr := matches[1], matches[2]
		propPath = append(propPath, propName)
		enumRequirements = append(enumRequirements, parseEnumRequirementsExpression(propPath, enumRequirementsExpr)...)
	}
	return
}

// parseEnumRequirementsExpression parses the provided enum requirements expression and returns the resulting enum
// requirements.
func parseEnumRequirementsExpression(basePropPath []string, enumReqsExpr string) []*schema.EnumRequirement {
	allMatches := enumRequirementsRegex.FindAllStringSubmatch(enumReqsExpr, -1)
	requirements := make([]*schema.EnumRequirement, 0, len(allMatches))
	for _, matches := range allMatches {
		propName, propValue := matches[1], matches[2]
		requirements = append(requirements, &schema.EnumRequirement{
			PathSegments: append(basePropPath, propName),
			Value:        propValue,
		})
	}
	return requirements
}

// parseWithClauses parses the provided list of with clauses and returns the resulting enum requirements.
func parseWithClauses(withClauses []string) ([]*schema.EnumRequirement, error) {
	requirements := make([]*schema.EnumRequirement, 0, len(withClauses))
	for _, withClause := range withClauses {
		splitWithClause := strings.Split(withClause, "=")
		if len(splitWithClause) != 2 {
			return nil, fmt.Errorf("cannot recognize --with clause format in %q", withClause)
		}

		enumPath, enumValue := splitWithClause[0], splitWithClause[1]
		enumPathSegments := strings.Split(enumPath, ".")
		requirement := &schema.EnumRequirement{PathSegments: enumPathSegments, Value: enumValue}
		requirements = append(requirements, requirement)
	}
	return requirements, nil
}
